### 事件机制
前提知识:  
JavaScript引擎常贮内存中,等待着宿主投递代码给他执行.

事件循环:  
JavaScript引擎无休止地运行着,等待着事件的到来.  
当接收到一个事件时,直接运行.如果收到多个事件,则创建一个`任务队列`,依次执行,直到为空.

##### 事件循环机制:  
1. JavaScript引擎将任务分为同步任务和异步任务.  
2. 同步任务,通过`执行栈`维持执行顺序,主线程执行来自执行栈的同步任务.  
3. 异步任务,直接被挂起,等有了运行结果,它的回调函数进入`事件队列`.  
4. 等执行栈被清空,事件队列中的第一个任务进入主线程,执行.  
5. 一直执行,直到所有的任务被执行完毕. 

另一个版本（描述角度不同，但是相同的）
1. 同步任务按顺序执行,（相关微任务，放入微任务队列，相关宏任务，放入宏任务队列）
2. 清空微任务队列，
3. 清空宏任务队列，（相关微任务，放入微任务队列，相关宏任务，放入宏任务队列）
4. 清空微任务队列
5. 清空宏任务队列，（相关微任务，放入微任务队列，相关宏任务，放入宏任务队列）
6. 清空微任务队列
7. ...


##### 同步任务/异步任务
JavaScript引擎是单线程运行机制.  
某个事件可能消耗很多时间,如果按照单线程机制,会出现很长一段无法操作.  
同步任务: 按顺序执行
异步任务: 先执行`微任务`,后执行`宏任务`  
微任务:  `Promise().then` `MutationObserve` `queueMicrotask` 
宏任务:  
### JavaScript性能优化
当有多个请求,且请求之间无相互依赖时,使用`Promise.all`  

### await 与 promise.then
使用await关键字等待Promise对象的状态变化，相当于在Promise对象的then方法中注册回调函数，并在回调函数中执行后续的代码。

例如:
```JavaScript
async function foo() {
  await Promise.resolve();
  console.log('foo finished');
}

Promise.resolve().then(() => console.log('foo finished'););
```